#--
# Version: 0.1(27-Mar-2017)
# Author: Thomas LEE
# Edited by: Thomas LEE
#--

import re

import numpy as np
import pandas as pd

from constant import Constant as con

#--
# EventGrid object
# An object that receive a csv file contains events and tickets details, csv file is generated by generate_event.py
# Constructor:
#   data_path: path of the csv file
#   grid_boundaries: the boundaries of the grid
#--
class EventGrid(object):
    def __init__(self, data_path='csv_data/data.csv', grid_boundaries={}):
        try:
            self.tickets = pd.read_csv(data_path)
            self.events = self.tickets[['event_id', 'x', 'y']].drop_duplicates()
        except IOError as ioe:
            raise Exception('File Exception: %s' % ioe)

        self.grid_boundaries = grid_boundaries

    #--
    # Given a certain position, return a datafrmame contains n nearest events with its cheapest ticket price
    # input:
    #   pos: the query position
    #   n_nearest: number of nearest events to be returned
    # return:
    #   a dataframe contains n nearest events with its cheapest price
    #--
    def search(self, pos, n_nearest=5):
        if(self.is_position_falls_within_grid(pos)):
            # 1. Calculate distance
            event_cp = self.events.copy()
            event_cp['distance'] = [self.manhattan_distance(event_loc, pos) for event_loc in zip(event_cp.x, event_cp.y)]

            # 2. Get the lowest price
            event_cp = event_cp.sort_values(by=['distance', 'event_id'], ascending=True)

            # 3. Merge price df
            event_candidates = pd.merge(
                event_cp[['event_id', 'distance']],
                self.tickets[['event_id', 'price']].groupby('event_id').min(),
                how='left',
                left_on='event_id',
                right_index=True
            )
            # 4. return first n events with tickets
            return event_candidates.dropna().head(n_nearest)

        else:
            raise Exception('Query position out of boundaries: %s' % pos)

    #--
    # Given a position, return a boolean that tells if the position is falls within the grid
    # input:
    #   pos: a position to be determined
    # return:
    #   a boolean tells if the position falls within the grid
    #--
    def is_position_falls_within_grid(self, pos):
        return self.is_falls_within(pos[0], self.grid_boundaries['x_min'], self.grid_boundaries['x_max']) and self.is_falls_within(pos[1], self.grid_boundaries['y_min'], self.grid_boundaries['y_max'])
    
    #--
    # Given x and a range, tells if it falls within the given range
    # input:
    #   x: value to be test
    #   min: lowerbound of the range
    #   max: upperbound of the range
    # return:
    #   boolean that tells if x falls with min and max
    #--
    def is_falls_within(self, x, min, max):
        return x >= min and x <= max

    #--
    # Calculate distance by manhattan distance
    # input:
    #   src: tuple of (x, y) of starting point
    #   dest: tuple of (x, y) of ending point
    # return:
    #   manhattan distance metric
    #--
    def manhattan_distance(self, src, dest):
        sx, sy = src
        dx, dy = dest
        return abs(sx - dx) + abs(sy - dy)

if __name__ == "__main__":
    grid = EventGrid(**con.GRID_CONF)

    # Ask for user input
    tuple_pattern = re.compile("^\d+,\d+$")

    print 'Please Input Coordinates:'
    query = raw_input()

    # Check the format
    while not tuple_pattern.match(query):
        print 'Incorrect format of input %s, correct format: integer,integer'
        print 'Try Again:'
        query = raw_input()

    # Transform query to tuple
    query = (int(query.split(',')[0]), int(query.split(',')[1]))

    # Search
    result = grid.search(query)

    # Print result
    event_id_width = len(str(result.event_id.max()))
    price_width = len(str(result.price.max()))

    print 'Closest Events to %s:' % str(query)
    print
    for idx, each_ticket in result.iterrows():
        print 'Event %0*d - $%0*.2f, Distance %d' % (event_id_width, each_ticket.event_id, price_width, each_ticket.price, each_ticket.distance)
